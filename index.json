[{"content":"当我们想终止一个运行中golang程序, 往往会使用 ctrl+c 或者 kill -9 \u0026lt;pid\u0026gt; 来杀死程序。当我们正在运行一些原子性操作的代码的时候(比如写文件)， 这样操作的话可能会导致问题产生。 因此需要有一个优雅的处理方式，等原子性的操作代码处理完后，再终止程序。\n可以使用 golang的 os.Signal 来捕获系统的终止操作\nsig := make(chan os.Signal) signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL, syscall.SIGTERM) POSIX中定义的信号\n使用2个channel通信的方式 func main() { sig := make(chan os.Signal) stopCh := make(chan struct{}) finishedCh := make(chan struct{}) signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL) go func(stopCh, finishedCh chan struct{}) { for { select { case \u0026lt;-stopCh: fmt.Println(\u0026#34;stopped\u0026#34;) finishedCh \u0026lt;- struct{}{} return default: time.Sleep(time.Second * 10) } } }(stopCh, finishedCh) //程序被挂起 等待singal \t\u0026lt;-sig stopCh \u0026lt;- struct{}{} //等待子routine 返回 \t\u0026lt;-finishedCh fmt.Println(\u0026#34;finished\u0026#34;) }  父goroutine通知子goroutine准备优雅地关闭，也就是stopCh 子goroutine通知父goroutine已经关闭完成，也就是finishedCh  嵌套 channel func main() { sig := make(chan os.Signal) stopCh := make(chan chan struct{}) signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL) go func(stopChh chan chan struct{}) { for { select { case ch := \u0026lt;-stopCh: // 结束后，通过ch通知主goroutine \tfmt.Println(\u0026#34;stopped\u0026#34;) ch \u0026lt;- struct{}{} return default: time.Sleep(time.Second) } } }(stopCh) \u0026lt;-sig // ch作为一个channel，传递给子goroutine，待其结束后从中返回 \tch := make(chan struct{}) stopCh \u0026lt;- ch \u0026lt;-ch fmt.Println(\u0026#34;finished\u0026#34;) } 使用Context func main() { sig := make(chan os.Signal) signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL) ctx, cancel := context.WithCancel(context.Background()) finishedCh := make(chan struct{}) go func(ctx context.Context, finishedCh chan struct{}) { for { select { case \u0026lt;-ctx.Done(): // 结束后，通过ch通知主goroutine \tfmt.Println(\u0026#34;stopped\u0026#34;) finishedCh \u0026lt;- struct{}{} return default: time.Sleep(time.Second) } } }(ctx, finishedCh) \u0026lt;-sig cancel() \u0026lt;-finishedCh fmt.Println(\u0026#34;finished\u0026#34;) } Context + waitGroup func main() { sig := make(chan os.Signal) signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL) ctx, cancel := context.WithCancel(context.Background()) num := 10 // 用wg来控制多个子goroutine的生命周期 \twg := sync.WaitGroup{} wg.Add(num) for i := 0; i \u0026lt; num; i++ { go func(ctx context.Context) { defer wg.Done() for { select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;stopped\u0026#34;) return default: time.Sleep(time.Duration(i) * time.Second) } } }(ctx) } \u0026lt;-sig cancel() // 等待所有的子goroutine都优雅退出 \twg.Wait() fmt.Println(\u0026#34;finished\u0026#34;) } 参考  os.Signal\n ","permalink":"https://shawnrong.github.io/posts/golang%E4%BC%98%E9%9B%85%E7%9A%84%E9%80%80%E5%87%BA%E4%B8%BB%E7%BA%BF%E7%A8%8B/","summary":"当我们想终止一个运行中golang程序, 往往会使用 ctrl+c 或者 kill -9 \u0026lt;pid\u0026gt; 来杀死程序。当我们正在运行一些原子性操作的代码的时候(比如写文件)， 这样操作的话可能会导致问题产生。 因此需要有一个优雅的处理方式，等原子性的操作代码处理完后，再终止程序。\n可以使用 golang的 os.Signal 来捕获系统的终止操作\nsig := make(chan os.Signal) signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL, syscall.SIGTERM) POSIX中定义的信号\n使用2个channel通信的方式 func main() { sig := make(chan os.Signal) stopCh := make(chan struct{}) finishedCh := make(chan struct{}) signal.Notify(sig, syscall.SIGINT, syscall.SIGKILL) go func(stopCh, finishedCh chan struct{}) { for { select { case \u0026lt;-stopCh: fmt.Println(\u0026#34;stopped\u0026#34;) finishedCh \u0026lt;- struct{}{} return default: time.Sleep(time.Second * 10) } } }(stopCh, finishedCh) //程序被挂起 等待singal \t\u0026lt;-sig stopCh \u0026lt;- struct{}{} //等待子routine 返回 \t\u0026lt;-finishedCh fmt.","title":"Golang优雅的退出主线程"},{"content":"Hooks 是React16.8最新引入的特性。使用Hooks可以在函数式组件中管理state。\nHooks 带来的好处可以让更简洁的让UI与状态分离，使代码更加清晰。\n说明 使用Hooks的前提是在函数式组件中。所以不能再使用React类组件的几个生命周期函数(需要通过useEffect来实现)\n开始 前端项目万物基于TODO APP 😂 , 接一下使用Hooks来创建一个TODO APP。\nuseState useState 接受一个初始化参数， 返回一个值和set方法\ntodo 组件：\nconst todo = props =\u0026gt; { const [todoName, setTodoName] = useState(\u0026#39;\u0026#39;) const [todoList, setTodoList] = useState([]) const inputChangeHandler = event =\u0026gt; { setTodoName(event.target.value) } const todoAddHandler = () =\u0026gt; { setTodoList(todoList.concat(todoName)) } return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Todo\u0026#34; value={todoName} onChange={inputChangeHandler} /\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onClick={todoAddHandler}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {todoList.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;item\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/React.Fragment\u0026gt; ) } useEffect 通过向useEffect穿不同的参数，可以模拟原来类组件中的生命周期方法。\nconst mouseMoveHandler = event =\u0026gt; { console.log(event.clientX, event.clientY) } useEffect(() =\u0026gt; { document.addEventListener(\u0026#39;mousemove\u0026#39;, mouseMoveHandler) return () =\u0026gt; { document.removeEventListener(\u0026#39;mousemove\u0026#39;, mouseMoveHandler) } }, []) 使用useEffect(fn, [])可以差不多的模拟componentDidMount。 不传第二个deps参数， 每次render都会执行useEffect\nuseEffect返回callback 表示 clean up,模拟 unmount。在[]可以中指定监听的对象scope ，当对象改变时，执行useEffect。\n这篇文章详细的说明了useEffect中异步state状态更新和this指向的问题\nuseContext 在类组件中使用React context,需要使用 jsx\n\u0026lt;MyContext.Consumer\u0026gt; {value =\u0026gt; /* render something based on the context value */} \u0026lt;/MyContext.Consumer\u0026gt; 这样包起来，然后有了useContext, 在子组件直接使用即可\nconst context = useContext(MyContext) useRef useRef返回一个可变的ref引用。可以把TODO input输入改写为：\nconst todo = props =\u0026gt; { const todoInputRef = useRef() ... //获取input的值  // const todoName = todoInputRef.current.value  return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Todo\u0026#34; ref={todoInputRef} ... \u0026lt;/React.Fragment\u0026gt; ) } useReducer 在API处理异步的时候当网络慢的时候state会更新错误，比如：\nconst todoAddHandler = () =\u0026gt; { axios.post(\u0026#39;api\u0026#39;, {name: todoName}) .then(res =\u0026gt; { setTimeout(() =\u0026gt; { const todoItem = {id: res.data.name, name: todoName } //当连续添加时，当前的todoList只能更新一个值  setTodoList(todoList.concat(todoItem)) }, 3000) }).catch(err =\u0026gt; { console.log(err) }) } 可以添加一个flagState来处理\nconst [submittedTodo, setSubmittedTodo] = useState(null) useEffect(() =\u0026gt; { if (submittedTodo) { setTodoList(todoList.concat(submittedTodo)) } }, [submittedTodo]) const todoAddHandler = () =\u0026gt; { axios.post(\u0026#39;api\u0026#39;, {name: todoName}) .then(res =\u0026gt; { setTimeout(() =\u0026gt; { const todoItem = {id: res.data.name, name: todoName } // 只更新submittedTodo  setSubmittedTodo(todoItem) }, 3000) }).catch(err =\u0026gt; { console.log(err) }) } 当然 更好的方法可以使用useReducer来解决这个问题\nconst todoListReducer = (state, action) =\u0026gt; { switch (action.type) { case \u0026#39;ADD\u0026#39;: return state.concat(action.payload) case \u0026#39;SET\u0026#39;: return action.payload case \u0026#39;REMOVE\u0026#39;: return state.filter(todo =\u0026gt; todo.id !== action.payload) default: return state } } const [todoList, dispatch] = useReducer(todoListReducer, []) const todoAddHandler = () =\u0026gt; { axios.post(\u0026#39;api\u0026#39;, {name: todoName}) .then(res =\u0026gt; { setTimeout(() =\u0026gt; { const todoItem = {id: res.data.name, name: todoName } dispatch({type: \u0026#39;ADD\u0026#39;, payload: todoItem}) }, 3000) }).catch(err =\u0026gt; { console.log(err) }) } useMemo useMemo 用于优化性能，省略不必要的重新render\n比如 将 TODO App 每一个item 封装成一个List组件：\n// List const list = props =\u0026gt; { console.log(\u0026#39;Rendering the list...\u0026#39;) return \u0026lt;ul\u0026gt; { props.items.map(todo =\u0026gt; ( \u0026lt;li key={todo.id} onClick={props.onClick.bind(this,todo.id)}\u0026gt;{todo.name}\u0026lt;/li\u0026gt; )) } \u0026lt;/ul\u0026gt; } // TODO const todo = props =\u0026gt; { ... return ( .... {useMemo(() =\u0026gt; \u0026lt;List items={todoList} onClick={todoRemoveHandler}/\u0026gt;, [todoList] )} ) } 自定义hook 自定义一个useFormInput\n// form.js export const useFormInput = () =\u0026gt; { const [value, setValue] = useState(\u0026#39;\u0026#39;) const [validity, setValidity] = useState(false) const inputChangeHandler = event =\u0026gt; { setValue(event.target.value) if(event.target.value.trim() === \u0026#39;\u0026#39;) { setValidity(false) } else { setValidity(true) } } return { value: value, onChange: inputChangeHandler, validity } } //todo.js const todo = props =\u0026gt; { const todoInput = useFormInput() return ( ... \u0026lt;React.Fragment\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Todo\u0026#34; onChange={todoInput.onChange} value={todoInput.value} style={{backgroudColor: todoInput.validity ? \u0026#39;transparent\u0026#39; : \u0026#39;red\u0026#39;}} /\u0026gt; ... ) } 样例\n参考  A Complete Guide to useEffect How to fetch data with React Hooks?  ","permalink":"https://shawnrong.github.io/posts/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8react-hooks/","summary":"Hooks 是React16.8最新引入的特性。使用Hooks可以在函数式组件中管理state。\nHooks 带来的好处可以让更简洁的让UI与状态分离，使代码更加清晰。\n说明 使用Hooks的前提是在函数式组件中。所以不能再使用React类组件的几个生命周期函数(需要通过useEffect来实现)\n开始 前端项目万物基于TODO APP 😂 , 接一下使用Hooks来创建一个TODO APP。\nuseState useState 接受一个初始化参数， 返回一个值和set方法\ntodo 组件：\nconst todo = props =\u0026gt; { const [todoName, setTodoName] = useState(\u0026#39;\u0026#39;) const [todoList, setTodoList] = useState([]) const inputChangeHandler = event =\u0026gt; { setTodoName(event.target.value) } const todoAddHandler = () =\u0026gt; { setTodoList(todoList.concat(todoName)) } return ( \u0026lt;React.Fragment\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Todo\u0026#34; value={todoName} onChange={inputChangeHandler} /\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onClick={todoAddHandler}\u0026gt;Add\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {todoList.map((item, index) =\u0026gt; ( \u0026lt;li key={index}\u0026gt;item\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/React.","title":"开始使用React Hooks"},{"content":"GraphQL简介 GraphQL是一种api查询语言，GraphQL并不用绑定具体的数据库或者存储引擎,它是描述请求的一个规范，类似于RESTful, 可以利用已有的代码和技术来进行数据源管理。一个GraphQL查询是一个被发往服务端的字符串，该查询在服务端被解释和执行后返回JSON数据给客户端。\nGraphQL基本语法 GraphQL基本语法可以分为 Fields,Arguments, Alias, Fragments,Operation name,Variables 操作可以分为Query和Mutation，query就是对数据进行查询，而mutation则是对数据进行操作，如增删改。 GraphQL是强类型的协议，支持的具体的数据类型有Int, Float, String, Boolean, ID\nQuery //下面是一个简单的GraphQL查询，获取id为1的用户的ID，名字,邮箱，所有评论 //其中id,name,email,comments都为fields //id:1为arguments //nickname为alias //...queryComments是fragment //findUser是operation name 可以省略 query findUser { user(id: 1) { id name:nickname #可以给字段设置alias email comments { content } # ...queryComments } } fragment queryComments on Comments { content } Mutation //新建一个用户，然后返回id和名字 //❗️表示字段必输 mutation createUser($id: ID!, $name: String!, $email: String) { createUser(id: $id, name: $name, email: $email) { id name } } //variables { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Tom\u0026quot;, \u0026quot;email\u0026quot;: \u0026quot;tom@test.com\u0026quot; } 与RESTful api对比  可拓展性。随着一个API的不断发展，需求的信息可能随时发生变化。如果需要前后端API信息匹配，这样就增加了开发和维护的难度。往往会有冗余信息。 同时对多个API接口的调用。往往会有一个复杂的数据请求，需要调用用户信息，评论接口等等，RESTful需要进行多次调用，这样的数据获取方式非常不灵活。  当然，GraphQL也有存在的问题，GraphQL每个查询的字段都有自己的一个resolve的方法，如果一次查询操作对数据库跑了大量的query,数据库的查询可能会成为性能瓶颈\nGraphQL应用场景  字段冗余 节约带宽 参数的类型校验 强类型协议 文档与维护， 文档会自动生成 请求多个接口   graplql.org\n ","permalink":"https://shawnrong.github.io/posts/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8graphql/","summary":"GraphQL简介 GraphQL是一种api查询语言，GraphQL并不用绑定具体的数据库或者存储引擎,它是描述请求的一个规范，类似于RESTful, 可以利用已有的代码和技术来进行数据源管理。一个GraphQL查询是一个被发往服务端的字符串，该查询在服务端被解释和执行后返回JSON数据给客户端。\nGraphQL基本语法 GraphQL基本语法可以分为 Fields,Arguments, Alias, Fragments,Operation name,Variables 操作可以分为Query和Mutation，query就是对数据进行查询，而mutation则是对数据进行操作，如增删改。 GraphQL是强类型的协议，支持的具体的数据类型有Int, Float, String, Boolean, ID\nQuery //下面是一个简单的GraphQL查询，获取id为1的用户的ID，名字,邮箱，所有评论 //其中id,name,email,comments都为fields //id:1为arguments //nickname为alias //...queryComments是fragment //findUser是operation name 可以省略 query findUser { user(id: 1) { id name:nickname #可以给字段设置alias email comments { content } # ...queryComments } } fragment queryComments on Comments { content } Mutation //新建一个用户，然后返回id和名字 //❗️表示字段必输 mutation createUser($id: ID!, $name: String!, $email: String) { createUser(id: $id, name: $name, email: $email) { id name } } //variables { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;Tom\u0026quot;, \u0026quot;email\u0026quot;: \u0026quot;tom@test.","title":"开始使用GraphQL"},{"content":"Docker note  docker info显示详细的信息 docker 命令行格式docker \u0026lt;command\u0026gt; \u0026lt;sub-command\u0026gt; (option) command 一般指manage command,比如docker container run --detach\\-d参数，使container在后台运行 docker container run 会一直新建一个container,使用docker container start启用一个已存在的 docker container --help docker container logs [containerName]显示container 日志信息 docker container top [containerName]显示container进程  docker container run -d -p 3306:3306 --name db -e MYSQL_RANDOM_ROOT_PASSWORD=yes mysql 新建一个mysql, docker container logs db 查看生成的密码 docker container inspect container配置详细 docker container stats查看所有container 状态 docker container exec -it [name] bash 进入container docker container port [name] docker image history [imagename:tag] 查看历史 docker image tag ...更换标签  dockerfile build  docker build -f some-dockerfile docker image build -t [tag name] .  RUN ln -sf /dev/stdout /var/log/nginx/access.log \\ \u0026amp;\u0026amp; ln -sf /dev/stderr /var/log/nginx/error.log # forward request and error logs to docker log collector  WORKDIR 切换目录 docker volume ls 查看挂在目录  docker compose  docker-compose -f  version: '3.1' # if no version is specificed then v1 is assumed. Recommend v2 minimum services: # containers. same as docker run servicename: # a friendly name. this is also DNS name inside network image: # Optional if you use build: command: # Optional, replace the default CMD specified by the image environment: # Optional, same as -e in docker run volumes: # Optional, same as -v in docker run servicename2: volumes: # Optional, same as docker volume create networks: # Optional, same as docker network create  docker-compose ps  ","permalink":"https://shawnrong.github.io/posts/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"Docker note  docker info显示详细的信息 docker 命令行格式docker \u0026lt;command\u0026gt; \u0026lt;sub-command\u0026gt; (option) command 一般指manage command,比如docker container run --detach\\-d参数，使container在后台运行 docker container run 会一直新建一个container,使用docker container start启用一个已存在的 docker container --help docker container logs [containerName]显示container 日志信息 docker container top [containerName]显示container进程  docker container run -d -p 3306:3306 --name db -e MYSQL_RANDOM_ROOT_PASSWORD=yes mysql 新建一个mysql, docker container logs db 查看生成的密码 docker container inspect container配置详细 docker container stats查看所有container 状态 docker container exec -it [name] bash 进入container docker container port [name] docker image history [imagename:tag] 查看历史 docker image tag .","title":"Docker常用命令"},{"content":"理解Laravel IOC容器 IOC容器是Laravel框架一个非常重要的概念\n依赖注入 理解IOC容器首先要从依赖注入开始。依赖注入和控制反转是差不多因果关系，通过使用依赖注入这种手段实现功能模块对其依赖组件的控制反转。\n拿一个使用OAuth登录应用场景举例：\ninterface Login { public function login(); } //微信账号登录 class WechatLogin implements Login { public function __construct(){} public function login() {} } //新浪微博登录 class WeiboLogin implements Login { public function __construct(){} public function login() {} } //QQ登录 class QQLogin implements Login { public function __construct(){} public function login() {} } //站点登录 class SiteLogin { protected $oauthClient; public function setOauthClient($oauthClient) { $this-\u0026gt;oauthClient = $oauthClient } public function appLogin() { $this-\u0026gt;oauthClient-\u0026gt;login(); } } 一般可以使用两种方法实现注入\n 通过构造函数注入依赖 通过setter设置方法注入  依赖注入的作用就是使程序更容易维护，降低代码的耦合度。但是，依赖注入也有缺点，就是每次都需要实例化，如果组件中有很多的依赖关系，就需要多个setter或者创建构造方法传递。这就需要用到了依赖注入容器\nLaravel的容器 在Laravel框架中，服务容器是整个框架的核心，它提供了整个系统功能及服务的配置，调用。当程序运行时，我们把需要的一些服务放到或者注册到(bind)到容器中，当我们需要的时候直接取出来(make)。\n\u0026lt;?php //容器类装实例或提供实例的回调函数 class Container { //用于装提供实例的回调函数，真正的容器还会装实例等其他内容  //从而实现单例等高级功能  protected $bindings = []; //绑定接口和生成相应实例的回调函数  public function bind($abstract, $concrete=null, $shared=false) { //如果提供的参数不是回调函数，则产生默认的回调函数  if(!$concrete instanceof Closure) { $concrete = $this-\u0026gt;getClosure($abstract, $concrete); } $this-\u0026gt;bindings[$abstract] = compact(\u0026#39;concrete\u0026#39;, \u0026#39;shared\u0026#39;); } //默认生成实例的回调函数  protected function getClosure($abstract, $concrete) { return function($c) use ($abstract, $concrete) { $method = ($abstract == $concrete) ? \u0026#39;build\u0026#39; : \u0026#39;make\u0026#39;; return $c-\u0026gt;$method($concrete); }; } public function make($abstract) { $concrete = $this-\u0026gt;getConcrete($abstract); if($this-\u0026gt;isBuildable($concrete, $abstract)) { $object = $this-\u0026gt;build($concrete); } else { $object = $this-\u0026gt;make($concrete); } return $object; } protected function isBuildable($concrete, $abstract) { return $concrete === $abstract || $concrete instanceof Closure; } //获取绑定的回调函数  protected function getConcrete($abstract) { if(!isset($this-\u0026gt;bindings[$abstract])) { return $abstract; } return $this-\u0026gt;bindings[$abstract][\u0026#39;concrete\u0026#39;]; } //实例化对象  public function build($concrete) { if($concrete instanceof Closure) { return $concrete($this); } $reflector = new ReflectionClass($concrete); if(!$reflector-\u0026gt;isInstantiable()) { echo $message = \u0026#34;Target [$concrete] is not instantiable\u0026#34;; } $constructor = $reflector-\u0026gt;getConstructor(); if(is_null($constructor)) { return new $concrete; } $dependencies = $constructor-\u0026gt;getParameters(); $instances = $this-\u0026gt;getDependencies($dependencies); return $reflector-\u0026gt;newInstanceArgs($instances); } //解决通过反射机制实例化对象时的依赖  protected function getDependencies($parameters) { $dependencies = []; foreach($parameters as $parameter) { $dependency = $parameter-\u0026gt;getClass(); if(is_null($dependency)) { $dependencies[] = NULL; } else { $dependencies[] = $this-\u0026gt;resolveClass($parameter); } } return (array)$dependencies; } protected function resolveClass(ReflectionParameter $parameter) { return $this-\u0026gt;make($parameter-\u0026gt;getClass()-\u0026gt;name); } } 以上代码定义了一个容器\n$app = new Container(); $app-\u0026gt;bind(\u0026#34;Login\u0026#34;, \u0026#34;WechatLogin\u0026#34;);//Login 为接口， WechatLogin 是 class WechatLogin $app-\u0026gt;bind(\u0026#34;siteLogin\u0026#34;, \u0026#34;SiteLogin\u0026#34;); //siteLogin可以当做是Class SiteLogin 的服务别名  //通过字符解析，或得到了Class SiteLogin 的实例 $login = $app-\u0026gt;make(\u0026#34;siteLogin\u0026#34;); $login-\u0026gt;appLogin(); 参考   如何理解 Laravel 的 IoC 容器 Laravel IoC Container: Why we need it and How it works Laravel5.6文档   ","permalink":"https://shawnrong.github.io/posts/%E7%90%86%E8%A7%A3laravel-ioc%E5%AE%B9%E5%99%A8/","summary":"理解Laravel IOC容器 IOC容器是Laravel框架一个非常重要的概念\n依赖注入 理解IOC容器首先要从依赖注入开始。依赖注入和控制反转是差不多因果关系，通过使用依赖注入这种手段实现功能模块对其依赖组件的控制反转。\n拿一个使用OAuth登录应用场景举例：\ninterface Login { public function login(); } //微信账号登录 class WechatLogin implements Login { public function __construct(){} public function login() {} } //新浪微博登录 class WeiboLogin implements Login { public function __construct(){} public function login() {} } //QQ登录 class QQLogin implements Login { public function __construct(){} public function login() {} } //站点登录 class SiteLogin { protected $oauthClient; public function setOauthClient($oauthClient) { $this-\u0026gt;oauthClient = $oauthClient } public function appLogin() { $this-\u0026gt;oauthClient-\u0026gt;login(); } } 一般可以使用两种方法实现注入","title":"理解Laravel IOC容器"},{"content":"PHP反射机制 介绍  reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime — wikipedia\n 反射的关键点就是在运行时分析类或者对象的状态，导出或提取出关于类，方法，属性，参数等信息。\n代码例子 Reflection/Profile.php\nnamespace codetest\\Reflection; /** * Class Profile * * @package codetest\\Reflection */ class Profile { public function getUserName() { return \u0026#39;Foo\u0026#39;; } } $reflectionClass = new ReflectionClass(\u0026#39;codetest\\Reflection\\Profile\u0026#39;); //当然也可以 $reflectionClass = new ReflectionClass(codetest\\Reflection\\Profile::class); var_dump($reflectionClass-\u0026gt;getName()); // output: codetest\\Reflection\\Profile var_dump($reflectionClass-\u0026gt;getDocComment()); // output: /** // * Class Profile // * // * @package codetest\\Reflection // */ 应用场景 PHP的反射API,一般用到ReflectionClass和ReflectionMethod，\n常用ReflectionClassAPI\nReflectionClass::getMethods 获取方法的数组 ReflectionClass::getName 获取类名 ReflectionClass::hasMethod 检查方法是否已定义 ReflectionClass::hasProperty 检查属性是否已定义 ReflectionClass::isAbstract 检查类是否是抽象类（abstract） ReflectionClass::isFinal 检查类是否声明为 final ReflectionClass::isInstantiable 检查类是否可实例化 ReflectionClass::newInstance 从指定的参数创建一个新的类实例 常用ReflectionMethodAPI\nReflectionMethod::invoke 执行 ReflectionMethod::invokeArgs 带参数执行 ReflectionMethod::isAbstract 判断方法是否是抽象方法 ReflectionMethod::isConstructor 判断方法是否是构造方法 ReflectionMethod::isDestructor 判断方法是否是析构方法 ReflectionMethod::isFinal 判断方法是否定义 final ReflectionMethod::isPrivate 判断方法是否是私有方法 ReflectionMethod::isProtected 判断方法是否是保护方法 (protected) ReflectionMethod::isPublic 判断方法是否是公开方法 ReflectionMethod::isStatic 判断方法是否是静态方法 ReflectionMethod::setAccessible 设置方法是否访问 下面是Reflection API的几个应用场景：\n  获取指定类的父类\n$class = new ReflectionClass(\u0026#39;Child\u0026#39;); $class-\u0026gt;getParentClass()   获取类方法的注释文档\n$method = new ReflectionMethod(\u0026#39;Profile\u0026#39;, \u0026#39;getUserName\u0026#39;); $method-\u0026gt;getDocComment();   也可以使用**instanceof()和is_a()**方法来判断反射类\n$class = new ReflectionClass(\u0026#39;Profile\u0026#39;); $obj = new Profile(); var_dump($class-\u0026gt;isInstance($obj)); // bool(true) var_dump(is_a($obj, \u0026#39;Profile\u0026#39;)); // bool(true) var_dump($obj instanceof Profile); // bool(true)   获取方法调用\n$stu = new Student(); $ref = new ReflectionClass(Student::class); $method = $ref-\u0026gt;getMethod(\u0026#39;setName\u0026#39;); $method-\u0026gt;invoke($stu, \u0026#39;john\u0026#39;); var_dump($stu-\u0026gt;name);   执行private方法\nclass Student { private $name; private function setName($name) { $this-\u0026gt;name = $name; } } $stu = new Student(); $ref = new ReflectionClass($stu); $method = $ref-\u0026gt;getMethod(\u0026#39;setName\u0026#39;); $method-\u0026gt;setAccessible(true); $method-\u0026gt;invoke($stu, \u0026#39;john\u0026#39;); //读取私有属性 $stu = new Student(); $ref = new ReflectionClass($stu); $prop = $ref-\u0026gt;getProperty(\u0026#39;name\u0026#39;); $prop-\u0026gt;setAccessible(true); $val = $prop-\u0026gt;getValue($stu); var_dump($val);   Laravel 中的反射 Laravel中的依赖注入也用到了反射的方法\nmake方法源码\npublic function build($concrete){ $reflector = new ReflectionClass($concrete); $constructor = $reflector-\u0026gt;getConstructor(); if (is_null($constructor)) { return new $concrete; } $dependencies = $constructor-\u0026gt;getParameters(); $instances = $this-\u0026gt;resolveDependencies($dependencies); return $reflector-\u0026gt;newInstanceArgs($instances); } 参考  Dependency Injection (DI) Container in PHP\nIntroduction to PHP Reflection API\n ","permalink":"https://shawnrong.github.io/posts/php%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","summary":"PHP反射机制 介绍  reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime — wikipedia\n 反射的关键点就是在运行时分析类或者对象的状态，导出或提取出关于类，方法，属性，参数等信息。\n代码例子 Reflection/Profile.php\nnamespace codetest\\Reflection; /** * Class Profile * * @package codetest\\Reflection */ class Profile { public function getUserName() { return \u0026#39;Foo\u0026#39;; } } $reflectionClass = new ReflectionClass(\u0026#39;codetest\\Reflection\\Profile\u0026#39;); //当然也可以 $reflectionClass = new ReflectionClass(codetest\\Reflection\\Profile::class); var_dump($reflectionClass-\u0026gt;getName()); // output: codetest\\Reflection\\Profile var_dump($reflectionClass-\u0026gt;getDocComment()); // output: /** // * Class Profile // * // * @package codetest\\Reflection // */ 应用场景 PHP的反射API,一般用到ReflectionClass和ReflectionMethod，","title":"PHP反射机制"},{"content":"Composer Autoload 配置说明 谈到现代PHP,肯定离不开Composer。对于库的自动加载信息，Composer 生成了一个 vendor/autoload.php 文件。你可以简单的引入这个文件，你会得到一个免费的自动加载支持。(注意⚠️：php5.3之后才有namespace)\nrequire \u0026#39;vendor/autoload.php\u0026#39;; namespace的应用大大的给开发提供的便利。autoload 是composer.json中的一个配置参数。autoload利用命名空间进行对应规则或标准的路径映射，从而找到最终的类文件。\n四种Autoload模式 1. PSR-0 在 psr-0 key 下你定义了一个命名空间到实际路径的映射（相对于包的根目录）。注意，这里同样支持 PEAR-style 方式的约定（与命名空间不同，PEAR 类库在类名上采用了下划线分隔）。\n请注意，命名空间的申明应该以 \\\\ 结束，以确保 autoloader 能够准确响应。\n在 install/update 过程中，PSR-0 引用都将被结合为一个单一的键值对数组，存储至 vendor/composer/autoload_namespaces.php 文件中。\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-0\u0026#34;: { \u0026#34;Monolog\\\\\u0026#34;: \u0026#34;src/\u0026#34;, \u0026#34;Vendor\\\\Namespace\\\\\u0026#34;: \u0026#34;src/\u0026#34;, \u0026#34;Vendor_Namespace_\u0026#34;: \u0026#34;src/\u0026#34; } } } ⚠️下划线 _ 对 psr-0 是有特殊意义的。psr-0 的加载器会将类名中的 _ 解析成目录分隔符。\n即 Foo_Bar_Test 类会去加载 Foo/Bar/Test.php 文件。\n2. PSR-4 将实际路径定义为命名空间。\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Monolog\\\\\u0026#34;: \u0026#34;src/\u0026#34;, \u0026#34;Vendor\\\\Namespace\\\\\u0026#34;: \u0026#34;\u0026#34; } } } 3. Classmap classmap 引用的所有组合，都会在 install/update 过程中生成，并存储到 vendor/composer/autoload_classmap.php 文件中。这个 map 是经过扫描指定目录（同样支持直接精确到文件）中所有的 .php 和 .inc 文件里内置的类而得到的。当载入需要的类时直接取出路径，速度最快\n你可以用 classmap 生成支持支持自定义加载的不遵循 PSR-0/4 规范的类库。要配置它指向需要的目录，以便能够准确搜索到类文件。\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;classmap\u0026#34;: [\u0026#34;src/\u0026#34;, \u0026#34;lib/\u0026#34;, \u0026#34;Something.php\u0026#34;] } } 4. Files 如果你想要明确的指定，在每次请求时都要载入某些文件，那么你可以使用 \u0026lsquo;files\u0026rsquo; autoloading。通常作为函数库的载入方式（而非类库）\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;files\u0026#34;: [\u0026#34;src/MyLibrary/functions.php\u0026#34;] } } 主要用来载入一些没办法懒加载的公共函数, 比如一些工具函数。\nPSR-0和PSR-4区别   在composer中定义的namespace，PSR-4必须以\\结尾否则会抛出异常，PSR-0则不要求\n  PSR-0里面最后一个\\之后的类名中，如果有下划线，则会转换成路径分隔符，如Name_Space_Test会转换成Name\\Space\\Test.php。在PSR-4中下划线不存在实际意义\n  PSR-0有更深的目录结构，比如定义了namespace为 Foo\\Bar=\u0026gt;vendor\\foo\\bar\\src， use Foo\\Bar\\Tool\\Request调用namespace。 如果以PSR-0方式加载，实际的目录为vendor\\foo\\bar\\src\\Foo\\Bar\\Tool\\Request.php 如果以PSR-4方式加载，实际目录为vendor\\foo\\bar\\src\\Tool\\Request.php\n  其他 当你添加了新的 psr-0/psr-4 的规则，或者在 classmap/files 规则相应的目录下新增了文件时，都需要执行 dump-autoload 来刷新系统的自动载入。\n参考  Composer文档\ncomposer 自动载入 autoload 的使用详解 \n ","permalink":"https://shawnrong.github.io/posts/composer-autoload%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/","summary":"Composer Autoload 配置说明 谈到现代PHP,肯定离不开Composer。对于库的自动加载信息，Composer 生成了一个 vendor/autoload.php 文件。你可以简单的引入这个文件，你会得到一个免费的自动加载支持。(注意⚠️：php5.3之后才有namespace)\nrequire \u0026#39;vendor/autoload.php\u0026#39;; namespace的应用大大的给开发提供的便利。autoload 是composer.json中的一个配置参数。autoload利用命名空间进行对应规则或标准的路径映射，从而找到最终的类文件。\n四种Autoload模式 1. PSR-0 在 psr-0 key 下你定义了一个命名空间到实际路径的映射（相对于包的根目录）。注意，这里同样支持 PEAR-style 方式的约定（与命名空间不同，PEAR 类库在类名上采用了下划线分隔）。\n请注意，命名空间的申明应该以 \\\\ 结束，以确保 autoloader 能够准确响应。\n在 install/update 过程中，PSR-0 引用都将被结合为一个单一的键值对数组，存储至 vendor/composer/autoload_namespaces.php 文件中。\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-0\u0026#34;: { \u0026#34;Monolog\\\\\u0026#34;: \u0026#34;src/\u0026#34;, \u0026#34;Vendor\\\\Namespace\\\\\u0026#34;: \u0026#34;src/\u0026#34;, \u0026#34;Vendor_Namespace_\u0026#34;: \u0026#34;src/\u0026#34; } } } ⚠️下划线 _ 对 psr-0 是有特殊意义的。psr-0 的加载器会将类名中的 _ 解析成目录分隔符。\n即 Foo_Bar_Test 类会去加载 Foo/Bar/Test.php 文件。\n2. PSR-4 将实际路径定义为命名空间。\n{ \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;Monolog\\\\\u0026#34;: \u0026#34;src/\u0026#34;, \u0026#34;Vendor\\\\Namespace\\\\\u0026#34;: \u0026#34;\u0026#34; } } } 3.","title":"Composer Autoload 配置说明"},{"content":"Laravel 生命周期 生命周期概述 入口 publuc/index.php是一个Laravel应用程序的入口，是整个框架的起点。index.php代码不多，主要的阶段就是：\n 加载Composer项目依赖 创建一个app实例容器 接收并且处理http请求  生命周期详解 加载项目依赖 Laravel使用Composer进行包的管理，所有组件的加载工作，仅需要一行代码\nrequire __DIR__.\u0026#39;/../vendor/autoload.php\u0026#39;; 创建App实例 接下来便是创建应用实例(Illuminate\\Foundation\\Application)，也叫服务容器\n$app = require_once __DIR__.\u0026#39;/../bootstrap/app.php\u0026#39;; 整个初始化的过程包括：注册项目基础的ServiceProvider,注册SerciveProvider的Alias,注册目录路径等。\nbootstrap/app.php中也完成了内核绑定。\nLaravel会依据http请求的运行环境不同，将请求发送至相应的内核HTTP内核 或 Console内核。无论哪个内核，它们作用都是处理http请求。\n最终，HTTP内核用handlemethod,单纯的接收一个Request以及返回一个Response。\nHTTP内核 HTTP内核继承了Illuminate\\Foundation\\Http\\Kernal类，它定义了在执行请求之前运行的 bootstrappers 数组。包含完成环境检测，配置加载，异常处理，Facades注册，ServiceProvider注册，启动服务这6个引导程序。\nHTTP内核定义了所有被请求应用程序处理之前必须经过的HTTP中间件列表。 这些中间件可以处理 HTTP session 的读写, 可以判断服务器当前是否处于维护模式, 验证 CSRF token ( 为了保护服务器不受 CSRF 攻击 ) 等等功能.\nServiceProvider 最重要的引导操作之一就是加载应用程序的ServiceProvider。应用程序的所有ServiceProvider都在config/app.php配置文件的providers数组中配置。所有的provider都会调用register方法，由boot方法负责调用所有的被注册provider。\nServiceProvider负责引导所有框架的各种组件，如数据库、队列、验证和路由组件。也就是说，框架提供的每个功能都它们来引导并配置。因此也可以说，ServiceProvider是整个 Laravel 引导过程中最重要的方面。\n接收并处理请求 处理请求包含两个阶段：\n 创建请求实例 处理请求  创建请求实例 请求实例`Illuminate\\Http\\Request`的`capture()\t`方法，内部通过Symfony实例创建一个Laravel请求实例  /** * Create a new Illuminate HTTP request from server variables. * * @class Illuminate\\Http\\Request * @return static */ public static function capture() { static::enableHttpMethodParameterOverride(); return static::createFromBase(SymfonyRequest::createFromGlobals()); } /** * Create an Illuminate request from a Symfony instance. * * @see https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Request.php * @param \\Symfony\\Component\\HttpFoundation\\Request $request * @return \\Illuminate\\Http\\Request */ public static function createFromBase(SymfonyRequest $request) { if ($request instanceof static) { return $request; } $content = $request-\u0026gt;content; $request = (new static)-\u0026gt;duplicate( $request-\u0026gt;query-\u0026gt;all(), $request-\u0026gt;request-\u0026gt;all(), $request-\u0026gt;attributes-\u0026gt;all(), $request-\u0026gt;cookies-\u0026gt;all(), $request-\u0026gt;files-\u0026gt;all(), $request-\u0026gt;server-\u0026gt;all() ); $request-\u0026gt;content = $content; $request-\u0026gt;request = $request-\u0026gt;getInputSource(); return $request; } 处理请求 请求处理发生在HTTP内核的handle()方法内\n/** * Handle an incoming HTTP request. * * @class Illuminate\\Foundation\\Http\\Kernel * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function handle($request) { try { $request-\u0026gt;enableHttpMethodParameterOverride(); $response = $this-\u0026gt;sendRequestThroughRouter($request); } catch (Exception $e) { $this-\u0026gt;reportException($e); $response = $this-\u0026gt;renderException($request, $e); } catch (Throwable $e) { $this-\u0026gt;reportException($e = new FatalThrowableError($e)); $response = $this-\u0026gt;renderException($request, $e); } $this-\u0026gt;app[\u0026#39;events\u0026#39;]-\u0026gt;dispatch( new Events\\RequestHandled($request, $response) ); return $response; } handle()方法接收一个HTTP请求，返回一个HTTP响应。\n发送响应 发送响应由Illuminate\\Http\\Response父类Symfony\\Component\\HttpFoundation\\Response中的send()方法完成。\n/** * Sends HTTP headers and content. * * @see https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Response.php * @return $this */ public function send() { $this-\u0026gt;sendHeaders();// 发送响应头部信息  $this-\u0026gt;sendContent();// 发送报文主题  if (function_exists(\u0026#39;fastcgi_finish_request\u0026#39;)) { fastcgi_finish_request(); } elseif (!\\in_array(PHP_SAPI, array(\u0026#39;cli\u0026#39;, \u0026#39;phpdbg\u0026#39;), true)) { static::closeOutputBuffers(0, true); } return $this; } 终止程序 程序终止，完成terminateMiddleware的调用\n参考   深度挖掘 Laravel 生命周期 Request Life Cycle of Laravel Laravel请求生命周期 Laravel 的请求周期   ","permalink":"https://shawnrong.github.io/posts/laravel%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"Laravel 生命周期 生命周期概述 入口 publuc/index.php是一个Laravel应用程序的入口，是整个框架的起点。index.php代码不多，主要的阶段就是：\n 加载Composer项目依赖 创建一个app实例容器 接收并且处理http请求  生命周期详解 加载项目依赖 Laravel使用Composer进行包的管理，所有组件的加载工作，仅需要一行代码\nrequire __DIR__.\u0026#39;/../vendor/autoload.php\u0026#39;; 创建App实例 接下来便是创建应用实例(Illuminate\\Foundation\\Application)，也叫服务容器\n$app = require_once __DIR__.\u0026#39;/../bootstrap/app.php\u0026#39;; 整个初始化的过程包括：注册项目基础的ServiceProvider,注册SerciveProvider的Alias,注册目录路径等。\nbootstrap/app.php中也完成了内核绑定。\nLaravel会依据http请求的运行环境不同，将请求发送至相应的内核HTTP内核 或 Console内核。无论哪个内核，它们作用都是处理http请求。\n最终，HTTP内核用handlemethod,单纯的接收一个Request以及返回一个Response。\nHTTP内核 HTTP内核继承了Illuminate\\Foundation\\Http\\Kernal类，它定义了在执行请求之前运行的 bootstrappers 数组。包含完成环境检测，配置加载，异常处理，Facades注册，ServiceProvider注册，启动服务这6个引导程序。\nHTTP内核定义了所有被请求应用程序处理之前必须经过的HTTP中间件列表。 这些中间件可以处理 HTTP session 的读写, 可以判断服务器当前是否处于维护模式, 验证 CSRF token ( 为了保护服务器不受 CSRF 攻击 ) 等等功能.\nServiceProvider 最重要的引导操作之一就是加载应用程序的ServiceProvider。应用程序的所有ServiceProvider都在config/app.php配置文件的providers数组中配置。所有的provider都会调用register方法，由boot方法负责调用所有的被注册provider。\nServiceProvider负责引导所有框架的各种组件，如数据库、队列、验证和路由组件。也就是说，框架提供的每个功能都它们来引导并配置。因此也可以说，ServiceProvider是整个 Laravel 引导过程中最重要的方面。\n接收并处理请求 处理请求包含两个阶段：\n 创建请求实例 处理请求  创建请求实例 请求实例`Illuminate\\Http\\Request`的`capture()\t`方法，内部通过Symfony实例创建一个Laravel请求实例  /** * Create a new Illuminate HTTP request from server variables.","title":"Laravel 生命周期"}]